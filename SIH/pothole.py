# -*- coding: utf-8 -*-
"""Pothole.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15MAP5QDj7GAj3YtNztNLA6CdJ7R_gcxZ
"""

from google.colab import drive
drive.mount('/content/gdrive')

import tensorflow as tf

from tensorflow.keras import datasets, layers, models
import matplotlib.pyplot as plt

# Commented out IPython magic to ensure Python compatibility.
# %ls

from keras.preprocessing.image import ImageDataGenerator


train_datagen = ImageDataGenerator(
        rescale=1./255,
        shear_range=0.2,
        zoom_range=0.2,
        horizontal_flip=True)

test_datagen = ImageDataGenerator(rescale=1./255)

training_set = train_datagen.flow_from_directory(
        'dataset/training_set/',
        target_size=(224, 224),
        batch_size=32,
        class_mode='binary')

test_set = test_datagen.flow_from_directory(
        'dataset/test_set/',
        target_size=(224, 224),
        batch_size=32,
        class_mode='binary')

training_set.class_indices

model = models.Sequential()
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.GlobalAveragePooling2D())

model.add(layers.Dense(1))

model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

history = model.fit(training_set, epochs=10, 
                    validation_data=test_set)



# plt.plot(history.history['accuracy'], label='accuracy')
# plt.plot(history.history['val_accuracy'], label = 'val_accuracy')
# plt.xlabel('Epoch')
# plt.ylabel('Accuracy')
# plt.ylim([0.5, 1])
# plt.legend(loc='lower right')

import numpy as np
from keras.preprocessing import image

img = image.load_img('dataset/training_set/pothole/13.jpg', target_size = (224, 224))
img = image.img_to_array(img)
img = np.expand_dims(img, axis=0)
result = model.predict(img)

print(result[0][0])